import bs58check from 'bs58check';
import bs58 from 'bs58';
import {
  privateToAddress,
  ecsign,
  toRpcSig,
  toBuffer,
} from 'ethereumjs-util'

import {
  parseMigrationRequest,
  validateMigrationRequest,
  getAddressesFromPayloadSig,
  checkReqWindow,
  hashMessageForSigning
} from '../src/util';

import {removeMigrationReq} from '../src/db-utils';
import supertest from 'supertest';
import {getServer, setupDbForServer} from "../src/server";
import {setupLogglyForAPI} from "../src/log";

require('dotenv').config();

describe('Validate migration request payload', () => {
  const privateKey = Buffer.from('efca4cdd31923b50f4214af5d2ae10e7ac45a5019e9431cc195482d707485378', 'hex');
  let address;
  
  beforeAll( () => {
    address = privateToAddress(privateKey);
  });

  function genTestPayloadAndSig(withBonus = null) {
    // The client will generate signature
    const mainnetAddress = '39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm';
    const txnHash = '5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a';
    let payloadRaw = Buffer.concat([bs58.decode(mainnetAddress), Buffer.from(txnHash, 'hex')]);
    if (withBonus !== null) {
      payloadRaw = Buffer.concat([payloadRaw, Buffer.from(new Uint8Array([withBonus]))]);
    }
    // Payload with checksum
    const payloadCheck = bs58check.encode(payloadRaw);
    // Generate by client
    const payloadHash = hashMessageForSigning(payloadCheck);
    // Generated by client
    const sig = ecsign(payloadHash, privateKey);
    const sigHex = toRpcSig(sig.v, sig.r, sig.s);
    return [payloadCheck, Buffer.from(sigHex.slice(2), 'hex')];
  }

  test('Parse payload', () => {
    // Prepare payload, this will be done by the client sending migration request.
    const expectedMainnetAddress = '39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm';
    const expectedTxnHash = '5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a';
    // Signature computed and sent by the client
    const base58Sig = '93pdQkvNzfquz5M8KgZgi7Q2QmqEPHEo8YXw3ERSvMgFS18Yn5rD9VFrSJfApLSgh7H92DdNnFQTV8x7vbEhHcfY7'
    const expectedPayloadRaw = Buffer.concat([bs58.decode(expectedMainnetAddress), Buffer.from(expectedTxnHash, 'hex')]);
    // Payload sent by the client
    const payloadCheck = bs58check.encode(expectedPayloadRaw);

    const [payload, sigBytes] = parseMigrationRequest({payload: payloadCheck, signature: base58Sig});
    expect(payload).toStrictEqual(payloadCheck);
    expect(sigBytes).toStrictEqual(bs58.decode(base58Sig));
  });

  test('Verify signature', async () => {
    const [payloadCheck, sig] = genTestPayloadAndSig();
    expect(getAddressesFromPayloadSig(payloadCheck, sig)).toBe(address.toString('hex'));
    const badSig = sig.slice(0, 64);
    expect(() => getAddressesFromPayloadSig(payloadCheck, badSig)).toThrow();
  });

   test('Validate migration request without bonus', () => {
     // Payload and signature sent by client
     const [payloadCheck, sig] = genTestPayloadAndSig();
     const [mainnetAddress, ethAddress, txnHash, , isVesting] = validateMigrationRequest({payload: payloadCheck, signature: bs58.encode(sig)});
     expect(mainnetAddress).toBe('39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm');
     expect(ethAddress).toBe(address.toString('hex'));
     expect(txnHash).toBe('5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a');
     expect(isVesting).toBe(null);
  });

  test('Validate migration request with bonus', () => {
    // Test both vesting and non vesting
    [1, 0].forEach(v => {
      // Payload and signature sent by client
      const [payloadCheck, sig] = genTestPayloadAndSig(v);
      const [mainnetAddress, ethAddress, txnHash, , isVesting] = validateMigrationRequest({payload: payloadCheck, signature: bs58.encode(sig)}, true);
      expect(mainnetAddress).toBe('39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm');
      expect(ethAddress).toBe(address.toString('hex'));
      expect(txnHash).toBe('5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a');
      expect(isVesting).toBe(Boolean(v));
    });
  });

  describe('Request window', () => {
    // Will hold original values of env variables changed during test as they need to be restored after tests are done
    let bReal, mReal;

    beforeAll(() => {
      bReal = process.env.BONUS_ENDS_AT;
      mReal = process.env.MIGRATION_ENDS_AT;
    });

    test('Bonus', () => {
      const now = (new Date()).getTime();

      // Window is open
      process.env.BONUS_ENDS_AT = (now + 100000).toString();
      expect(() => checkReqWindow(true)).not.toThrow();

      // Close bonus window
      process.env.BONUS_ENDS_AT = (now - 10000).toString();
      expect(() => checkReqWindow(true)).toThrow('Bonus window is closed');
    });

    test('Without bonus', () => {
      const now = (new Date()).getTime();

      // Window is open
      process.env.MIGRATION_ENDS_AT = (now + 100000).toString();
      expect(() => checkReqWindow(false)).not.toThrow();

      // Close bonus window
      process.env.MIGRATION_ENDS_AT = (now - 10000).toString();
      expect(() => checkReqWindow(false)).toThrow('Migration is over');
    });

    test('sign and verify message from MyCrypto', () => {
      [
          ['d25DJj7azNUJXfEbYLpr5PUjuYydDE51c1EvaLKsgCq83Gs6QHYjwtRp4PirP8DadNfWNwc5bahGQ8mmceoTnLejFMcWtgtWz8', '0x1094926cfb4d83fc7814f0547be3214a6d01ab32f5af242b9521fe9d1a00789e6a389dd1461a927c6242da48e1b5a359ff4510f5b74705658555ffba5ad263b71b', '8c854bc1b6b1122d27c6489c57dfc53e56a94910'],
          ['d25DJj7azNUJXfEbYLpr5PUjuYydDE51c1EvaLKsgCq83Gs4AehvNnABQQ1GENtoh8f4TWyBWJBHT5cH9xwJFvkMaJoR6tgsvq', '0x07fe6f31411bad6c2ea3bd4066db5519a09790067cb8dbb875e63f571f4a46ed7747151280fd4bc949564874b0a9e2db28cedd93558c814ff86bb9012322ba4d1c', '1a3432b0a5c5c46ec55e7e58fe47f2a1d5aa1b9b'],
          ['dfcHMaJJFe3ib5P9C2AjtruCMFCcJZsxW2sttLC1HnC2StsdcrMHAyd4og98b3UfsdxCCkx2kS57kRW5KJa1uJiHW4Xwaa2ZNq', '0xc3ef4f30caab576686b82dbb32e6c14a0aeeb8f8dbc300057552b32fe1dc4fde7edb32a26c8f9b581e28bd91c41ac38e9fbb0c095d976bd48fa02a259483ba2f1b', '1a3432b0a5c5c46ec55e7e58fe47f2a1d5aa1b9b']
      ].forEach(([msg, sig, expectedAddr]) => {
        const addr = getAddressesFromPayloadSig(msg, toBuffer(sig));
        expect(addr).toBe(expectedAddr);
      });
    })

    test('API server works', async () => {
      const server = getServer();
      // XXX: This logix is tightly coupled with logging and database.
      const dbClient = await setupDbForServer(server);
      setupLogglyForAPI();
      const testingServer = supertest(server);
      const addr = address.toString('hex');
      const txH = '5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a';

      [1, 0].forEach( async (v) => {
        const [payloadCheck, sig] = genTestPayloadAndSig(v);

        const response1 = await testingServer.post('/migrate_with_bonus').set('Accept', 'application/json').send({payload: payloadCheck, signature: bs58.encode(sig)});
        expect(response1.status).toBe(200);

        const response2 = await testingServer.post('/status').set('Accept', 'application/json').send({address: addr, txnHash: txH});
        expect(response2.status).toBe(200);

        const response3 = await testingServer.get('/statistics').set('Accept', 'application/json').auth(process.env.STATS_ADMIN_NAME, process.env.STATS_ADMIN_KEY);
        expect(response3.status).toBe(200);

        await removeMigrationReq(dbClient, addr, '5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a');
      });

      await dbClient.stop();

    }, 20000)

    afterAll(() => {
      process.env.BONUS_ENDS_AT = bReal;
      process.env.MIGRATION_ENDS_AT = mReal;
    });
  });

});