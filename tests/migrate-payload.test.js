import bs58check from 'bs58check';
import bs58 from 'bs58';
import { privateToAddress, hashPersonalMessage, ecsign, toRpcSig } from 'ethereumjs-util'

import {parseMigrationRequest, validateMigrationRequest, verifyPayloadSig} from '../src/util';
import {getNewWeb3MainnetClient} from "../src/eth-txn-utils";
import {DBClient} from "../src/db-utils";
import {processPendingRequests} from "../src/migrations";

describe('Validate migration request payload', () => {
  const privateKey = Buffer.from('efca4cdd31923b50f4214af5d2ae10e7ac45a5019e9431cc195482d707485378', 'hex');
  let address, payloadCheck, signature, web3Client, dbClient;
  
  beforeAll( async (done) => {
    address = privateToAddress(privateKey);
    dbClient = new DBClient();
    await dbClient.start();
    web3Client = getNewWeb3MainnetClient();
    done();
  });

  function genTestPayloadAndSig() {
    // The client will generate signature
    const mainnetAddress = '39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm';
    const txnHash = '5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a';
    const payloadRaw = Buffer.concat([bs58.decode(mainnetAddress), Buffer.from(txnHash, 'hex')]);
    const payloadCheck = bs58check.encode(payloadRaw);
    // Generate by client
    const payloadHash = hashPersonalMessage(bs58.decode(payloadCheck));
    // Generated by client
    const sig = ecsign(payloadHash, privateKey);
    const sigHex = toRpcSig(sig.v, sig.r, sig.s);
    return [payloadCheck, Buffer.from(sigHex.slice(2), 'hex')];
  }

  test('Parse payload', () => {
    // Prepare payload, this will be done by the client sending migration request.
    const expectedMainnetAddress = '39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm';
    const expectedTxnHash = '5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a';
    // Signature computed and sent by the client
    const base58Sig = '93pdQkvNzfquz5M8KgZgi7Q2QmqEPHEo8YXw3ERSvMgFS18Yn5rD9VFrSJfApLSgh7H92DdNnFQTV8x7vbEhHcfY7'
    const expectedPayloadRaw = Buffer.concat([bs58.decode(expectedMainnetAddress), Buffer.from(expectedTxnHash, 'hex')]);
    // Payload sent by the client
    payloadCheck = bs58check.encode(expectedPayloadRaw);

    const [payloadBytes, sigBytes] = parseMigrationRequest({payload: payloadCheck, signature: base58Sig});
    expect(payloadBytes).toStrictEqual(bs58.decode(payloadCheck));
    expect(sigBytes).toStrictEqual(bs58.decode(base58Sig));
  });

  test('Verify signature', async () => {
    const [payloadCheck, sig] = genTestPayloadAndSig();
    expect(verifyPayloadSig(bs58.decode(payloadCheck), sig)).toBe(address.toString('hex'));
  });

   test('Validate migration request', async () => {
     // Payload and signature sent by client
     const [payloadCheck, sig] = genTestPayloadAndSig();
     const [mainnetAddress, ethAddress, txnHash] = validateMigrationRequest({payload: payloadCheck, signature: bs58.encode(sig)});
     expect(mainnetAddress).toBe('39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm');
     expect(ethAddress).toBe(address.toString('hex'));
     expect(txnHash).toBe('5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a');
  });

  test('Check pending request', async () => {
    const r = await processPendingRequests(dbClient, web3Client)
    // TODO:
  }, 30000)
});