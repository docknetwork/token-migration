import bs58check from 'bs58check';
import bs58 from 'bs58';
import { privateToAddress, hashPersonalMessage, ecsign, toRpcSig } from 'ethereumjs-util'

import {parseMigrationRequest, validateMigrationRequest, verifyPayloadSig, checkReqWindow} from '../src/util';
import {getNewWeb3MainnetClient} from "../src/eth-txn-utils";

require('dotenv').config();

describe('Validate migration request payload', () => {
  const privateKey = Buffer.from('efca4cdd31923b50f4214af5d2ae10e7ac45a5019e9431cc195482d707485378', 'hex');
  let address, payloadCheck, web3Client, dbClient;
  
  beforeAll( () => {
    address = privateToAddress(privateKey);
    web3Client = getNewWeb3MainnetClient();
  });

  function genTestPayloadAndSig(withBonus = null) {
    // The client will generate signature
    const mainnetAddress = '39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm';
    const txnHash = '5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a';
    let payloadRaw = Buffer.concat([bs58.decode(mainnetAddress), Buffer.from(txnHash, 'hex')]);
    if (withBonus !== null) {
      payloadRaw = Buffer.concat([payloadRaw, Buffer.from(new Uint8Array([withBonus]))]);
    }
    const payloadCheck = bs58check.encode(payloadRaw);
    // Generate by client
    const payloadHash = hashPersonalMessage(bs58.decode(payloadCheck));
    // Generated by client
    const sig = ecsign(payloadHash, privateKey);
    const sigHex = toRpcSig(sig.v, sig.r, sig.s);
    return [payloadCheck, Buffer.from(sigHex.slice(2), 'hex')];
  }

  test('Parse payload', () => {
    // Prepare payload, this will be done by the client sending migration request.
    const expectedMainnetAddress = '39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm';
    const expectedTxnHash = '5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a';
    // Signature computed and sent by the client
    const base58Sig = '93pdQkvNzfquz5M8KgZgi7Q2QmqEPHEo8YXw3ERSvMgFS18Yn5rD9VFrSJfApLSgh7H92DdNnFQTV8x7vbEhHcfY7'
    const expectedPayloadRaw = Buffer.concat([bs58.decode(expectedMainnetAddress), Buffer.from(expectedTxnHash, 'hex')]);
    // Payload sent by the client
    payloadCheck = bs58check.encode(expectedPayloadRaw);

    const [payloadBytes, sigBytes] = parseMigrationRequest({payload: payloadCheck, signature: base58Sig});
    expect(payloadBytes).toStrictEqual(bs58.decode(payloadCheck));
    expect(sigBytes).toStrictEqual(bs58.decode(base58Sig));
  });

  test('Verify signature', async () => {
    const [payloadCheck, sig] = genTestPayloadAndSig();
    expect(verifyPayloadSig(bs58.decode(payloadCheck), sig)).toBe(address.toString('hex'));
  });

   test('Validate migration request without bonus', () => {
     // Payload and signature sent by client
     const [payloadCheck, sig] = genTestPayloadAndSig();
     const [mainnetAddress, ethAddress, txnHash, , isVesting] = validateMigrationRequest({payload: payloadCheck, signature: bs58.encode(sig)});
     expect(mainnetAddress).toBe('39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm');
     expect(ethAddress).toBe(address.toString('hex'));
     expect(txnHash).toBe('5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a');
     expect(isVesting).toBe(null);
  });

  test('Validate migration request with bonus', () => {
    // Test both vesting and non vesting
    [1, 0].forEach(v => {
      // Payload and signature sent by client
      const [payloadCheck, sig] = genTestPayloadAndSig(v);
      const [mainnetAddress, ethAddress, txnHash, , isVesting] = validateMigrationRequest({payload: payloadCheck, signature: bs58.encode(sig)}, true);
      expect(mainnetAddress).toBe('39QKJG54MzsG66GTjQwEwrZ6FEkXrEEVa4LsAt759UNrfYLm');
      expect(ethAddress).toBe(address.toString('hex'));
      expect(txnHash).toBe('5e618464858638cb8b4df51db776c7293d138b170103a999644de87aa93d138a');
      expect(isVesting).toBe(Boolean(v));
    });
  });

  describe('Request window', () => {
    // Will hold original values of env variables changed during test as they need to be restored after tests are done
    let bReal, mReal;

    beforeAll(() => {
      bReal = process.env.BONUS_ENDS_AT;
      mReal = process.env.MIGRATION_ENDS_AT;
    });

    test('Bonus', () => {
      const now = (new Date()).getTime();

      // Window is open
      process.env.BONUS_ENDS_AT = (now + 100000).toString();
      expect(() => checkReqWindow(true)).not.toThrow();

      // Close bonus window
      process.env.BONUS_ENDS_AT = (now - 10000).toString();
      expect(() => checkReqWindow(true)).toThrow('Bonus window is closed');
    });

    test('Without bonus', () => {
      const now = (new Date()).getTime();

      // Window is open
      process.env.MIGRATION_ENDS_AT = (now + 100000).toString();
      expect(() => checkReqWindow(false)).not.toThrow();

      // Close bonus window
      process.env.MIGRATION_ENDS_AT = (now - 10000).toString();
      expect(() => checkReqWindow(false)).toThrow('Migration is over');
    });

    afterAll(() => {
      process.env.BONUS_ENDS_AT = bReal;
      process.env.MIGRATION_ENDS_AT = mReal;
    });
  });

});